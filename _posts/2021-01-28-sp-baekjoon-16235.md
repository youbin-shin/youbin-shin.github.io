---
title: "[baekjoon] 16235. 나무 재테크 (python)"
author: youbin
date: 2021-01-28 10:10:00 +0800
categories: [Solve coding problems, baekjoon]
tags: [baekjoon, python]
---

### [16235. 나무 재테크 문제 바로가기](https://www.acmicpc.net/problem/16235)



# 해결 방법

## 동작 과정

### 동작하는 과정 설명

1. #### 입력받기

   **변수 설정**

   - `land` : 땅의 양분의 양을 저장하는 2차원 리스트
   - `tree` : 나무 위치에 나이를 저장할 2차원 리스트
   - `land_food` : 겨울에 더해줄 양분을 저장한 2차원 리스트

2. #### 나무 재테크 동작하기

   1. `**springSummer()`** 함수 호출하기 : 봄과 여름에 일어나는 동작을 수행!

      1. 나무가 존재하는 경우 나이 어린 순으로 정렬하기

         1. 땅의 양분이 나무의 나이보다 크거나 같은 경우

            - 나무 나이 += 1 (이때 5의 배수이면 fall_tree에 위치 저장하기)
            - 땅의 양분 -= 나무의 나이

         2. 땅의 양분이 나무의 나이보다 작은 경우

            맨 처음 죽는 나무 인덱스를 저장하여 이후 다음 과정을 실행한다.

            - 죽은 나무 땅의 양분 주기
            - 죽은 나무 제거하기

   2. `**fall()**` 함수 호출하기 : 가을에 일어나는 동작 수행!

      앞서 동작한 `springSummer()` 함수를 통해 번식할 나무 위치에 대한 리스트 fall_tree를 받아 번식시키기

   3. `**winter()**` 함수 호출하기 : 겨울에 일어나는 동작 수행!

      각 위치 별 양분 더하기

3. #### 2번의 과정을 K번 반복하기

4. #### 나무의 수 총 더하여 출력하기



## 구현한 코드

```python
def springSummer(): # 봄과 여름에 일어나는 동작을 수행하는 함수
    fall_tree = [] # 가을에 번식할 나무 위치 저장하는 리스트
    for r in range(N):
        for c in range(N):
            if tree[r][c] != []: # 나무가 존재하는 경우
                tree[r][c].sort() # 나무 나이 어린 순으로 정렬
                die_check = False # 나무가 죽는지 체크하는 변수 (summer 의 동작이 일어날지의 유무 결정)
                die_idx = 0 # 나무가 죽는 경우 맨 처음에 죽는 나무 인덱스

                tree_num = len(tree[r][c])
                # 1. 봄에 일어나는 동작
                for t in range(tree_num):
                    if land[r][c] >= tree[r][c][t]:
                        land[r][c] -= tree[r][c][t] # 나무가 자신의 나이만큼 양분 먹기
                        tree[r][c][t] += 1 # 나무 나이 1 증가
                        if tree[r][c][t] % 5 == 0: # 5의 배수
                            fall_tree.append([r, c])
                    else: # 양분을 먹지 못하고 죽음
                        if die_check == False: # 맨 처음에 죽는 나무의 인덱스를 저장하기 위한 조건
                            die_idx = t
                        die_check = True
                # 여름에 일어나는 동작
                if die_check: # 죽은 나무가 있는 경우만 동작하기에 분기하기
                    for d in range(die_idx, tree_num):
                        land[r][c] += int(tree[r][c][d] / 2) # 죽은 나무 양분으로 추가하기
                    tree[r][c] = tree[r][c][:die_idx] # 죽은 나무 제거하기

    fall(fall_tree) # 가을에 일어나는 동작 수행하는 함수


def fall(fall_tree): # 가을에 일어나는 동작 수행하는 함수
    dirs = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]
    for f in range(len(fall_tree)): # 나무의 나이가 5의 배수가 넘는 나무들 번식하기
        y, x = fall_tree[f][0], fall_tree[f][1]
        for d in range(8):
            ny, nx = y + dirs[d][0], x + dirs[d][1]
            if 0 <= ny < N and  0 <= nx < N:
                tree[ny][nx].append(1)
    winter() # 겨울에 일어나는 동작 수행하는 함수

def winter(): # 겨울에 일어나는 동작 수행하는 함수
    for i in range(N):
        for j in range(N):
            land[i][j] += land_food[i][j] # 양분 더하기


# 입력받기
N, M, K = map(int, input().split())
land = [list(5 for _ in range(N)) for _ in range(N)] # 땅의 양분의 양을 저장하는 리스트
tree = [[[] for _ in range(N)]  for _ in range(N)] # 나무 나이를 저장할 리스트
land_food = [list(map(int, input().split())) for _ in range(N)] # 겨울에 더해야하는 양분을 저장한 리스트
# 나무 위치에 나무 나이 저장하기
for _ in range(M):
    y, x, z = map(int, input().split())
    tree[y - 1][x - 1].append(z)
    
for _ in range(K):
    springSummer() # 봄과 여름에 일어나는 동작을 수행하는 함수

# 최종 결과 출력하기
tree_sum = 0
for r in range(N):
    for c in range(N):
        if tree[r][c] != []:
            tree_sum += len(tree[r][c]) # 나무의 수 더하기
print(tree_sum)
```



### 디버깅을 위한 `예제 입력 8` 동작 결과

```python
## 초기 설정
# 땅 양분의 양
[5, 5, 5, 5, 5]
[5, 5, 5, 5, 5]
[5, 5, 5, 5, 5]
[5, 5, 5, 5, 5]
[5, 5, 5, 5, 5]
# 나무 나이
[[], [], [], [], []]
[[3], [], [], [], []]
[[], [3], [], [], []]
[[], [], [], [], []]
[[], [], [], [], []]

## 1년 뒤
# 땅 양분의 양
[7, 8, 7, 8, 7]
[4, 8, 7, 8, 7]
[7, 5, 7, 8, 7]
[7, 8, 7, 8, 7]
[7, 8, 7, 8, 7]
# 나무 나이
[[], [], [], [], []]
[[4], [], [], [], []]
[[], [4], [], [], []]
[[], [], [], [], []]
[[], [], [], [], []]

## 2년 뒤
# 땅 양분의 양
[9, 11, 9, 11, 9]
[2, 11, 9, 11, 9]
[9, 4, 9, 11, 9]
[9, 11, 9, 11, 9]
[9, 11, 9, 11, 9]
# 나무 나이
[[1], [1], [], [], []]
[[5, 1], [1, 1], [1], [], []]
[[1, 1], [5, 1], [1], [], []]
[[1], [1], [1], [], []]
[[], [], [], [], []]

## 3년 뒤
# 땅 양분의 양
[10, 13, 11, 14, 11]
[5, 12, 10, 14, 11]
[9, 8, 10, 14, 11]
[10, 13, 10, 14, 11]
[11, 14, 11, 14, 11]
# 나무 나이
[[2], [2], [], [], []]
[[2], [2, 2], [2], [], []]
[[2, 2], [2], [2], [], []]
[[2], [2], [2], [], []]
[[], [], [], [], []]

## 4년 뒤
# 땅 양분의 양
[10, 14, 13, 17, 13]
[5, 11, 10, 17, 13]
[7, 9, 10, 17, 13]
[10, 14, 10, 17, 13]
[13, 17, 13, 17, 13]
# 나무 나이
[[3], [3], [], [], []]
[[3], [3, 3], [3], [], []]
[[3, 3], [3], [3], [], []]
[[3], [3], [3], [], []]
[[], [], [], [], []]

## 5년 뒤
# 땅 양분의 양
[9, 14, 15, 20, 15]
[4, 8, 9, 20, 15]
[3, 9, 9, 20, 15]
[9, 14, 9, 20, 15]
[15, 20, 15, 20, 15]
# 나무 나이
[[4], [4], [], [], []]
[[4], [4, 4], [4], [], []]
[[4, 4], [4], [4], [], []]
[[4], [4], [4], [], []]
[[], [], [], [], []]

## 6년 뒤
# 땅 양분의 양
[7, 13, 17, 23, 17]
[2, 3, 7, 23, 17]
[9, 8, 7, 23, 17]
[7, 13, 7, 23, 17]
[17, 23, 17, 23, 17]
#나무 나이
[[5, 1, 1, 1, 1], [5, 1, 1, 1, 1, 1], [1, 1, 1, 1], [1], []]
[[5, 1, 1, 1, 1, 1], [5, 5, 1, 1, 1, 1, 1, 1], [5, 1, 1, 1, 1, 1], [1, 1], []]
[[1, 1, 1, 1, 1, 1], [5, 1, 1, 1, 1, 1, 1, 1, 1], [5, 1, 1, 1, 1, 1, 1], [1, 1, 1], []]
[[5, 1, 1], [5, 1, 1, 1, 1], [5, 1, 1, 1], [1, 1], []]
[[1, 1], [1, 1, 1], [1, 1], [1], []]

# 최종 출력값 : 총 나무의 수
85
```



